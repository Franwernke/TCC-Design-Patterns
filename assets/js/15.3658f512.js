(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{291:function(e,a,o){"use strict";o.r(a);var s=o(14),r=Object(s.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[a("RouterLink",{attrs:{to:"/docs/"}},[e._v("< Voltar")])],1),e._v(" "),a("h2",{attrs:{id:"model-view-controller"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#model-view-controller"}},[e._v("#")]),e._v(" Model-View-Controller")]),e._v(" "),a("h3",{attrs:{id:"problema"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#problema"}},[e._v("#")]),e._v(" Problema")]),e._v(" "),a("p",[e._v("Organizar uma aplicação é sempre uma tarefa complicada. Porém, não ter nenhuma direção para a arquitetura de um sistema, é a receita para a desorganização em pouquíssimo tempo. Dessa forma, precisamos de uma guia para entendermos em que parte do software cada parte da lógica fica. Assim, conseguimos ler o código como uma linha de produção, onde cada subsistema tem seu papel bem-definido e regido por regras claras.")]),e._v(" "),a("p",[e._v("Apesar de existirem diversos padrões arquiteturais que possam ser seguidos, é muito importante que saibamos qual a intenção daquele padrão. Diferentemente de escolhas pontuais sobre o projeto que são tomadas de acordo com novas funcionalidades que são adicionadas, o padrão arquitetural tem efeitos duradouros e vai influenciar a construção do projeto do início ao fim.")]),e._v(" "),a("h3",{attrs:{id:"exemplo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#exemplo"}},[e._v("#")]),e._v(" Exemplo")]),e._v(" "),a("p",[e._v("Você precisa construir um novo front-end para apresentar dados internos sobre os usuários do seu produto. Esse front-end apresentará diversas telas, uma para cada entidade da empresa, com relações entre algumas delas. Essas telas serão construídas por várias equipes, cada uma terá seu contexto e entidade bem-definidas, de forma que uma equipe tenha que ter o mínimo de interação possível com outra equipe.")]),e._v(" "),a("p",[e._v("No começo, os projetos funcionam bem e as equipes conseguem navegar na complexidade de cada entidade. Porém, devido a um corte de verbas, algumas equipes são desfeitas e agora sua equipe deve dar manutenção a algumas outras entidades além da originalmente planejada para vocês.")]),e._v(" "),a("p",[e._v("Como não foi pensado nenhum padrão para a construção da tela de cada entidade, os softwares contruídos pelas equipes são profundamente diferentes. Agora, navegar pela complexidade de outras telas é uma tarefa complicada e dar manutenção é custoso.")]),e._v(" "),a("h3",{attrs:{id:"contexto"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contexto"}},[e._v("#")]),e._v(" Contexto")]),e._v(" "),a("ul",[a("li",[e._v("O software a ser construído deve permitir apresentar e modificat um modelo de dados de uma entidade")]),e._v(" "),a("li",[e._v("O software deve ser extensível a novas funcionalidades")]),e._v(" "),a("li",[e._v("A relação entre a tela, os dados que estamos trabalhando e as operações possíveis sobre eles é bem clara")])]),e._v(" "),a("h3",{attrs:{id:"solucao"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#solucao"}},[e._v("#")]),e._v(" Solução")]),e._v(" "),a("p",[e._v("O Model-View-Controller é um dos padrões arquiteturais mais antigos de toda a computação. Ele define a aplicação como três componentes básicos: Modelo, Visualização e Controles. Esta separação guia os programas para que saibamos onde encontrarmos cada tipo de lógica. Para front-ends, temos uma definição específica de cada um desses componentes:")]),e._v(" "),a("p",[e._v("Modelo: É uma representação das entidades do negócio geralmente armazenadas nos back-ends. Apesar do front-end não controlar diretamente o modelo, ainda é necessário que exista a sincronização do modelo interno do front-end com o modelo do back-end.")]),e._v(" "),a("p",[e._v("Visualizações: É o componente que estrutura as páginas e produz de fato o HTML e o CSS. Os componentes da aplicação se encontram aqui e eles devem conhecer o modelo para organizá-lo em páginas. A lógica destes elementos deve se limitar a apresentação e a modificação dos dados deve ser bastante restrita. Geralmente deixa-se uma camada intermediária entre os modelos e visualizações que permite a adaptação destes dados (vide padrão Adapter).")]),e._v(" "),a("p",[e._v("Controles: É o componente que estipula as ações possíveis sobre o modelo. Aqui, encontramos funções que executam chamadas para back-ends para alterarmos informações, também invalidando o modelo local e forçando sincronizações. Em aplicações modernas, é comum vermos os Controles muito próximos as visualizações (Se são unidos, podemos chamar de uma arquitetura MVVM).")]),e._v(" "),a("h3",{attrs:{id:"diagrama"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diagrama"}},[e._v("#")]),e._v(" Diagrama")]),e._v(" "),a("h3",{attrs:{id:"implementacao"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementacao"}},[e._v("#")]),e._v(" Implementação")])])}),[],!1,null,null,null);a.default=r.exports}}]);